// Generated by IcedCoffeeScript 108.0.11
(function() {
  var KeyManager, OuterLink, RotateKey, alloc_v3, bufeq_secure, bufferify, constants, errors, iced, make_esc, pack, parse, pgp_utils, schema, sha256, __iced_k, __iced_k_noop, _alloc_inner_obj, _check_chain, _check_inner, _check_prev, _hex_to_buffer, _parse_inputs, _parse_outer_link, _ref, _uid_eq, _verify_inner_hash, _verify_outer_sig;

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  make_esc = require('iced-error').make_esc;

  KeyManager = require('kbpgp').kb.KeyManager;

  constants = require('./constants').constants;

  _ref = require('./util'), pack = _ref.pack, bufferify = _ref.bufferify, sha256 = _ref.sha256;

  pgp_utils = require('pgp-utils');

  bufeq_secure = pgp_utils.util.bufeq_secure;

  parse = require('./parse3');

  OuterLink = require('./sig3').OuterLink;

  RotateKey = require('./team_hidden').RotateKey;

  errors = require('./errors').errors;

  schema = require('./schema3');

  _check_prev = function(a, b) {
    if (!(a != null) && !(b != null)) {
      return null;
    }
    if (!(a != null) || !(b != null)) {
      return new errors.BadPrevError("null versus non-null in prev comparison");
    }
    if (!bufeq_secure(a, b)) {
      return new errors.BadPrevError("hash mismatch in prevs");
    }
    return null;
  };

  _hex_to_buffer = function(h) {
    try {
      return parse.unhex(h);
    } catch (_error) {
      return null;
    }
  };

  _uid_eq = function(u1, u2) {
    u1 = _hex_to_buffer(u1);
    u2 = _hex_to_buffer(u2);
    return (u1 != null) && (u2 != null) && bufeq_secure(u1, u2);
  };

  _parse_inputs = function(_arg) {
    var armored, check_params, e, err, errout, json, km, raw, schm, skip_inner;
    armored = _arg.armored, km = _arg.km, skip_inner = _arg.skip_inner, check_params = _arg.check_params;
    errout = function(e) {
      return [new Error(e), {}];
    };
    if ((armored == null) || !parse.is_dict(armored)) {
      return errout('need a dictionary of armored, packed structs (inner and outer) and also a sig');
    }
    try {
      raw = parse.dearmor_dict(armored);
      json = parse.unpack_dict(raw);
    } catch (_error) {
      e = _error;
      return [e, {}];
    }
    if (((json != null ? json.outer : void 0) == null) || ((json != null ? json.sig : void 0) == null)) {
      return errout("need 'outer' and 'sig' fields");
    }
    if (!parse.is_array(json != null ? json.outer : void 0)) {
      return errout("'outer' must be an array");
    }
    if (!Buffer.isBuffer(json.sig) || json.sig.length !== 64) {
      return errout("'sig' must be a binary buffer (with a signature of 64 bytes)");
    }
    if (!skip_inner) {
      if ((json != null ? json.inner : void 0) == null) {
        return errout("need 'inner' or an explicit skip_inner flag");
      }
      if (!parse.is_dict(json.inner)) {
        return errout("'inner' must be a dictionary");
      }
    }
    if (km == null) {
      return errout("need non-null KeyManager km");
    }
    if (check_params == null) {
      return errout("need check_params");
    }
    schm = schema.dict({
      user: schema.dict({
        local: schema.dict({
          uid: schema.uid().name("uid").convert(),
          eldest_seqno: schema.seqno().name("eldest_seqno")
        })
      }),
      prev: schema.binary(32).optional().name("prev").convert(),
      seqno: schema.seqno().name("seqno")
    }).name("check_params");
    if ((err = schm.check(check_params)) != null) {
      return [err, {}];
    }
    return [
      null, {
        json: json,
        raw: raw
      }
    ];
  };

  _verify_outer_sig = function(_arg, cb) {
    var km, outer, sig;
    outer = _arg.outer, sig = _arg.sig, km = _arg.km;
    return km.verify_raw({
      prefix: bufferify(constants.sig_prefixes[constants.versions.sig_v3]),
      payload: outer,
      sig: sig
    }, cb);
  };

  _verify_inner_hash = function(_arg, cb) {
    var inner, km, outer_obj;
    inner = _arg.inner, outer_obj = _arg.outer_obj, km = _arg.km;
    return cb((bufeq_secure(outer_obj.inner_hash, sha256(inner)) ? null : new Error("outer's body hash doesn't match inner link")));
  };

  _parse_outer_link = function(_arg, cb) {
    var array;
    array = _arg.array;
    return cb.apply(null, OuterLink.decode(array));
  };

  _check_inner = function(_arg, cb) {
    var c, check_params, e, inner_obj, km;
    inner_obj = _arg.inner_obj, km = _arg.km, check_params = _arg.check_params;
    e = function(m) {
      return new Error(m);
    };
    c = function() {
      if (!_uid_eq(inner_obj.user.local.uid, check_params.user.local.uid)) {
        return e("bad UID");
      }
      if (inner_obj.user.local.eldest_seqno !== check_params.user.local.eldest_seqno) {
        return e("bad eldest_seqno");
      }
      if (!bufeq_secure(inner_obj.sig_eng.get_km().key.ekid(), km.key.ekid())) {
        return e("bad key ID");
      }
      return null;
    };
    return cb(c());
  };

  _check_chain = function(_arg, cb) {
    var check_params, err, outer_obj;
    outer_obj = _arg.outer_obj, check_params = _arg.check_params;
    if (outer_obj.seqno !== check_params.seqno) {
      err = new errors.WrongSeqnoError("bad sequence number in chain (" + outer_obj.seqno + " != " + check_params.seqno + ")");
    } else {
      err = _check_prev(outer_obj.prev, check_params.prev);
    }
    return cb(err);
  };

  _alloc_inner_obj = function(_arg, cb) {
    var esc, inner_json, klass, obj, outer_obj, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    outer_obj = _arg.outer_obj, inner_json = _arg.inner_json;
    esc = make_esc(cb);
    klass = (function() {
      switch (outer_obj.link_type) {
        case constants.sig_types_v3.team.rotate_key:
          return RotateKey;
        default:
          return null;
      }
    })();
    if (klass == null) {
      return cb(new Error("no class for type " + outer_obj.link_type));
    }
    obj = new klass({});
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/keybase/proofs/src/alloc3.iced"
        });
        obj.decode_inner({
          json: inner_json,
          outer_obj: outer_obj
        }, esc(__iced_deferrals.defer({
          lineno: 116
        })));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        return cb(null, obj);
      };
    })(this));
  };

  alloc_v3 = function(_arg, cb) {
    var armored, check_params, err, esc, json, km, now, objs, raw, skip_inner, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1, _ref2;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    armored = _arg.armored, km = _arg.km, skip_inner = _arg.skip_inner, check_params = _arg.check_params, now = _arg.now;
    esc = make_esc(cb);
    _ref1 = _parse_inputs({
      armored: armored,
      km: km,
      check_params: check_params
    }), err = _ref1[0], (_ref2 = _ref1[1], json = _ref2.json, raw = _ref2.raw);
    if (err != null) {
      return cb(err);
    }
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/keybase/proofs/src/alloc3.iced"
        });
        _verify_outer_sig({
          outer: raw.outer,
          sig: json.sig,
          km: km
        }, esc(__iced_deferrals.defer({
          lineno: 154
        })));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        objs = {};
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/proofs/src/alloc3.iced"
          });
          _parse_outer_link({
            array: json.outer
          }, esc(__iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                return __slot_1.outer = arguments[0];
              };
            })(objs),
            lineno: 156
          })));
          __iced_deferrals._fulfill();
        })(function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/proofs/src/alloc3.iced"
            });
            objs.outer.check({}, esc(__iced_deferrals.defer({
              lineno: 157
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/proofs/src/alloc3.iced"
              });
              _check_chain({
                outer_obj: objs.outer,
                check_params: check_params
              }, esc(__iced_deferrals.defer({
                lineno: 158
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                if (!skip_inner) {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/proofs/src/alloc3.iced"
                    });
                    _verify_inner_hash({
                      inner: raw.inner,
                      outer_obj: objs.outer
                    }, esc(__iced_deferrals.defer({
                      lineno: 160
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/Users/max/src/keybase/proofs/src/alloc3.iced"
                      });
                      _alloc_inner_obj({
                        outer_obj: objs.outer,
                        inner_json: json.inner
                      }, esc(__iced_deferrals.defer({
                        assign_fn: (function(__slot_1) {
                          return function() {
                            return __slot_1.inner = arguments[0];
                          };
                        })(objs),
                        lineno: 161
                      })));
                      __iced_deferrals._fulfill();
                    })(function() {
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename: "/Users/max/src/keybase/proofs/src/alloc3.iced"
                        });
                        _check_inner({
                          inner_obj: objs.inner,
                          km: km,
                          check_params: check_params
                        }, esc(__iced_deferrals.defer({
                          lineno: 162
                        })));
                        __iced_deferrals._fulfill();
                      })(function() {
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename: "/Users/max/src/keybase/proofs/src/alloc3.iced"
                          });
                          objs.inner.check({
                            now: now
                          }, esc(__iced_deferrals.defer({
                            lineno: 163
                          })));
                          __iced_deferrals._fulfill();
                        })(function() {
                          (function(__iced_k) {
                            __iced_deferrals = new iced.Deferrals(__iced_k, {
                              parent: ___iced_passed_deferral,
                              filename: "/Users/max/src/keybase/proofs/src/alloc3.iced"
                            });
                            objs.inner.verify_reverse_sig({
                              outer_obj: objs.outer,
                              inner: json.inner
                            }, esc(__iced_deferrals.defer({
                              lineno: 164
                            })));
                            __iced_deferrals._fulfill();
                          })(__iced_k);
                        });
                      });
                    });
                  });
                } else {
                  return __iced_k();
                }
              })(function() {
                return cb(null, {
                  objs: objs,
                  json: json,
                  raw: raw,
                  armored: armored
                });
              });
            });
          });
        });
      };
    })(this));
  };

  exports.alloc_v3 = alloc_v3;

}).call(this);
