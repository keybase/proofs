// Generated by IcedCoffeeScript 108.0.11
(function() {
  var bufeq_fast, constants, is_dict, is_hex, is_int, pack, unpack, unpack_strict,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  unpack = require('purepack').unpack;

  constants = require('./constants').constants;

  pack = require('./util').pack;

  bufeq_fast = require('pgp-utils').util.bufeq_fast;

  exports.is_dict = is_dict = function(o) {
    return typeof o === 'object' && !Array.isArray(o) && (o != null);
  };

  exports.is_array = function(o) {
    return typeof o === 'object' && Array.isArray(o);
  };

  exports.is_string = function(s) {
    return typeof s === 'string' && s.length > 0;
  };

  exports.is_uid = function(u) {
    return is_hex(u, 16);
  };

  exports.is_prev = function(p) {
    return !(p != null) || is_hex(p, 32);
  };

  exports.is_inner_link_hash = function(h) {
    return is_hex(h, 32);
  };

  exports.is_kid = function(h) {
    return is_hex(h, 35);
  };

  exports.is_int = is_int = function(s) {
    var n;
    n = Math.floor(Number(s));
    return typeof s === 'number' && (n !== Infinity) && (n === s) && n >= 0;
  };

  exports.is_hex = is_hex = function(h, l) {
    if (h == null) {
      return false;
    }
    if (typeof h === 'string') {
      h = Buffer.from(h, 'hex');
    } else if (!Buffer.isBuffer) {
      return false;
    }
    return h.length === l;
  };

  exports.is_seqno = function(s) {
    if (s == null) {
      return false;
    }
    if (!is_int(s)) {
      return false;
    }
    if (!(s >= 0 && s <= 99999999)) {
      return false;
    }
    return true;
  };

  exports.is_bool = function(b) {
    return typeof b === 'boolean';
  };

  exports.dearmor_dict = function(armored) {
    var k, raw, ret, v;
    if (!is_dict(armored)) {
      throw new Error("need an object of encodings");
    }
    ret = {};
    for (k in armored) {
      v = armored[k];
      raw = Buffer.from(v, 'base64');
      if (raw.toString('base64') !== v) {
        throw new Error("non-canonical base64-encoding in " + k);
      }
      ret[k] = raw;
    }
    return ret;
  };

  exports.unpack_dict = function(raw) {
    var k, ret, v;
    if (!is_dict(raw)) {
      throw new Error("need an object of packed objects");
    }
    ret = {};
    for (k in raw) {
      v = raw[k];
      ret[k] = unpack_strict(v);
    }
    return ret;
  };

  unpack_strict = function(v) {
    var expected, ret;
    ret = unpack(v);
    expected = pack(ret);
    if (!bufeq_fast(v, expected)) {
      throw new Error("strict decoding requirement failed");
    }
    return ret;
  };

  exports.is_link_type = function(x) {
    if (!is_int(x)) {
      return false;
    }
    if (x !== constants.sig_types_v3.user.peg && x !== constants.sig_types_v3.team.rotate_key) {
      return false;
    }
    return true;
  };

  exports.is_ptk_type = function(x) {
    if (!is_int(x)) {
      return false;
    }
    if (__indexOf.call(Object.values(constants.ptk_types), x) < 0) {
      return false;
    }
    return true;
  };

  exports.is_time = function(x) {
    if (!is_int(x)) {
      return false;
    }
    if (!(x > 0)) {
      return false;
    }
    if (!(x > 946702800)) {
      return false;
    }
    if (!(x < 1893474000)) {
      return false;
    }
    return true;
  };

  exports.is_chain_type = function(x) {
    var d, v, _, _ref;
    if (!is_int(x)) {
      return false;
    }
    d = {};
    _ref = constants.seq_types;
    for (_ in _ref) {
      v = _ref[_];
      if (v === x) {
        return true;
      }
    }
    return false;
  };

  exports.unhex = function(b) {
    if (b == null) {
      return null;
    } else if (Buffer.isBuffer(b)) {
      return b;
    } else if (typeof b === 'string') {
      return Buffer.from(b, 'hex');
    } else {
      throw new Error("bad binary or hex string");
    }
  };

}).call(this);
