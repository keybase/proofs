// Generated by IcedCoffeeScript 108.0.12
(function() {
  var Array, Binary, Bool, ChainType, Dict, Int, KID, LinkType, Node, Object, Or, Path, PtkType, Seqno, String, StringEnum, Struct, Time, Value, mkerr, parse,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  parse = require('./parse3');

  mkerr = function(path, err) {
    return new Error("At " + (path.toString()) + ": " + err);
  };

  Path = (function() {
    function Path(v) {
      this._v = v || [];
    }

    Path.prototype.extend = function(e) {
      return new Path(this._v.concat([e]));
    };

    Path.prototype.toString = function() {
      return this._v.join(".");
    };

    Path.top = function(n) {
      return new Path([n || "<top>"]);
    };

    return Path;

  })();

  Node = (function() {
    function Node(_arg) {
      _arg;
      this._optional = false;
      this._convert = false;
      this._name = "";
      this._path = [];
    }

    Node.prototype.optional = function() {
      this._optional = true;
      return this;
    };

    Node.prototype.is_optional = function() {
      return this._optional;
    };

    Node.prototype.convert = function() {
      this._convert = true;
      return this;
    };

    Node.prototype.name = function(n) {
      this._name = n;
      return this;
    };

    Node.prototype._check = function(_arg) {
      var obj, path;
      path = _arg.path, obj = _arg.obj;
      return mkerr(path, "internal error, no checker found");
    };

    Node.prototype.check = function(obj) {
      return this._check({
        path: Path.top(this._name),
        obj: obj
      });
    };

    Node.prototype.debug_localize = function(obj) {
      return obj;
    };

    Node.prototype._check_value = function(_arg) {
      var checker, obj, path;
      checker = _arg.checker, path = _arg.path, obj = _arg.obj;
      if ((obj == null) && checker.is_optional()) {
        return null;
      }
      if (obj == null) {
        mkerr(path, "value cannot be null");
      }
      return checker._check({
        path: path,
        obj: obj
      });
    };

    return Node;

  })();

  Dict = (function(_super) {
    __extends(Dict, _super);

    function Dict(_arg) {
      var keys;
      keys = _arg.keys;
      this._keys = keys;
      Dict.__super__.constructor.apply(this, arguments);
    }

    Dict.prototype._check = function(_arg) {
      var checker, err, k, new_path, obj, path, v, _ref;
      path = _arg.path, obj = _arg.obj;
      if (!parse.is_dict(obj)) {
        return mkerr(path, "need a dictionary");
      }
      for (k in obj) {
        v = obj[k];
        new_path = path.extend(k);
        if ((checker = this._keys[k]) == null) {
          return mkerr(new_path, "key is not supported");
        }
        if ((err = this._check_value({
          checker: checker,
          path: new_path,
          obj: v
        }))) {
          return err;
        }
      }
      _ref = this._keys;
      for (k in _ref) {
        v = _ref[k];
        new_path = path.extend(k);
        if ((obj[k] == null) && !v.is_optional()) {
          return mkerr(new_path, "key is missing but is mandatory");
        }
      }
      return null;
    };

    Dict.prototype.debug_localize = function(obj) {
      var k, ret, v, _ref;
      ret = {};
      _ref = this._keys;
      for (k in _ref) {
        v = _ref[k];
        if (obj[k] != null) {
          ret[v._name || k] = v.debug_localize(obj[k]);
        }
      }
      return ret;
    };

    Dict.prototype.set_key = function(k, v) {
      return this._keys[k] = v;
    };

    return Dict;

  })(Node);

  Array = (function(_super) {
    __extends(Array, _super);

    function Array(_arg) {
      var elem;
      elem = _arg.elem;
      this._elem = elem;
      this._empty_is_ok = false;
    }

    Array.prototype.empty_is_ok = function() {
      this._empty_is_ok = true;
      return this;
    };

    Array.prototype.debug_localize = function(obj) {
      var i, ret, v, _i, _len;
      ret = [];
      for (i = _i = 0, _len = obj.length; _i < _len; i = ++_i) {
        v = obj[i];
        ret[i] = this._elem.debug_localize(obj[i]);
      }
      return ret;
    };

    Array.prototype._check = function(_arg) {
      var err, i, new_path, o, obj, path, _i, _len;
      path = _arg.path, obj = _arg.obj;
      if (!parse.is_array(obj)) {
        return mkerr(path, "need an array");
      }
      if (!this._empty_is_ok && obj.length < 1) {
        return mkerr(path, "need 1 or more objects");
      }
      for (i = _i = 0, _len = obj.length; _i < _len; i = ++_i) {
        o = obj[i];
        new_path = path.extend(i.toString());
        if ((err = this._check_value({
          checker: this._elem,
          path: new_path,
          obj: o
        }))) {
          return err;
        }
      }
      return null;
    };

    return Array;

  })(Node);

  Struct = (function(_super) {
    __extends(Struct, _super);

    function Struct(_arg) {
      var slots;
      slots = _arg.slots;
      this._slots = slots;
    }

    Struct.prototype.debug_localize = function(obj) {
      var i, ret, v, _i, _len;
      ret = [];
      for (i = _i = 0, _len = obj.length; _i < _len; i = ++_i) {
        v = obj[i];
        ret[i] = this._slots[i].debug_localize(obj[i]);
      }
      return ret;
    };

    Struct.prototype._check = function(_arg) {
      var err, i, new_path, o, obj, path, _i, _len;
      path = _arg.path, obj = _arg.obj;
      if (!parse.is_array(obj)) {
        return mkerr(path, "need an array");
      }
      if (obj.length !== this._slots.length) {
        return mkerr(path, "need an array with " + this._slots.length + " fields");
      }
      for (i = _i = 0, _len = obj.length; _i < _len; i = ++_i) {
        o = obj[i];
        new_path = path.extend(i.toString());
        if ((err = this._check_value({
          checker: this._slots[i],
          path: new_path,
          obj: o
        }))) {
          return err;
        }
      }
      return null;
    };

    return Struct;

  })(Node);

  Binary = (function(_super) {
    __extends(Binary, _super);

    function Binary(_arg) {
      var bottom_bytes, len;
      len = _arg.len, bottom_bytes = _arg.bottom_bytes;
      this._len = len;
      this._bottom_bytes = bottom_bytes != null ? bottom_bytes.reduce((function(d, x) {
        d[x] = true;
        return d;
      }), {}) : null;
    }

    Binary.prototype._convert_and_check = function(_arg) {
      var bot, obj, path;
      path = _arg.path, obj = _arg.obj;
      if (this._convert && typeof obj === 'string') {
        obj = Buffer.from(obj, 'hex');
      }
      if (!(Buffer.isBuffer(obj) && obj.length === this._len)) {
        return [mkerr(path, "value needs to be buffer of length " + this._len), null];
      }
      if (this._bottom_bytes != null) {
        bot = obj[obj.length - 1];
        if (!this._bottom_bytes[bot]) {
          return [mkerr(path, "value has wrong bottom byte (" + bot + ")"), null];
        }
      }
      return [null, obj];
    };

    Binary.prototype._check = function(_arg) {
      var err, obj, path, _, _ref;
      path = _arg.path, obj = _arg.obj;
      _ref = this._convert_and_check({
        path: path,
        obj: obj
      }), err = _ref[0], _ = _ref[1];
      return err;
    };

    return Binary;

  })(Node);

  KID = (function(_super) {
    __extends(KID, _super);

    function KID(_arg) {
      var encryption;
      encryption = _arg.encryption;
      this._encryption = encryption;
      this._len = 35;
    }

    KID.prototype._check = function(_arg) {
      var err, obj, path, typ, _ref, _ref1;
      path = _arg.path, obj = _arg.obj;
      _ref = this._convert_and_check({
        path: path,
        obj: obj
      }), err = _ref[0], obj = _ref[1];
      if (err != null) {
        return err;
      }
      typ = this._encryption ? [0x21] : [0x20, 0x01, 0x11, 0x13, 0x16];
      if ((obj[0] !== 0x01) || (_ref1 = obj[1], __indexOf.call(typ, _ref1) < 0) || (obj.slice(-1)[0] !== 0x0a)) {
        return mkerr(path, "value must be a KID" + (this._encryption ? ' (for encryption)' : ''));
      }
      return null;
    };

    return KID;

  })(Binary);

  Seqno = (function(_super) {
    __extends(Seqno, _super);

    function Seqno() {
      return Seqno.__super__.constructor.apply(this, arguments);
    }

    Seqno.prototype._check = function(_arg) {
      var obj, path;
      path = _arg.path, obj = _arg.obj;
      if (!parse.is_seqno(obj)) {
        return mkerr(path, "value must be a seqno (sequence number)");
      }
      return null;
    };

    return Seqno;

  })(Node);

  Int = (function(_super) {
    __extends(Int, _super);

    function Int() {
      return Int.__super__.constructor.apply(this, arguments);
    }

    Int.prototype._check = function(_arg) {
      var obj, path;
      path = _arg.path, obj = _arg.obj;
      if (!parse.is_int(obj)) {
        return mkerr(path, "value must be an int");
      }
      return null;
    };

    return Int;

  })(Node);

  Time = (function(_super) {
    __extends(Time, _super);

    function Time() {
      return Time.__super__.constructor.apply(this, arguments);
    }

    Time.prototype._check = function(_arg) {
      var obj, path;
      path = _arg.path, obj = _arg.obj;
      if (!parse.is_time(obj)) {
        return mkerr(path, "value must be a UTC timestamp");
      }
      return null;
    };

    return Time;

  })(Node);

  ChainType = (function(_super) {
    __extends(ChainType, _super);

    function ChainType() {
      return ChainType.__super__.constructor.apply(this, arguments);
    }

    ChainType.prototype._check = function(_arg) {
      var obj, path;
      path = _arg.path, obj = _arg.obj;
      if (!parse.is_chain_type(obj)) {
        return mkerr(path, "value must be a valid chain type");
      }
      return null;
    };

    return ChainType;

  })(Node);

  String = (function(_super) {
    __extends(String, _super);

    function String(_arg) {
      var args;
      args = _arg.args;
      this._args = args;
    }

    String.prototype._check = function(_arg) {
      var max_length, obj, path, _ref;
      path = _arg.path, obj = _arg.obj;
      if (typeof obj !== 'string' || obj.length === 0) {
        return mkerr(path, "value must be a string");
      }
      if ((max_length = (_ref = this._args) != null ? _ref.max_length : void 0) != null) {
        if (obj.length > max_length) {
          return mkerr(path, "value length needs to be < " + max_length);
        }
      }
      return null;
    };

    return String;

  })(Node);

  StringEnum = (function(_super) {
    __extends(StringEnum, _super);

    function StringEnum(_arg) {
      var v, values, _i, _len;
      values = _arg.values;
      this._values = {};
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        v = values[_i];
        this._values[v] = true;
      }
    }

    StringEnum.prototype._check = function(_arg) {
      var obj, path;
      path = _arg.path, obj = _arg.obj;
      if (typeof obj !== 'string') {
        return mkerr(path, "value must be a string");
      }
      if (!this._values[obj]) {
        return mkerr(path, "unknown enum value (" + obj + ")");
      }
      return null;
    };

    return StringEnum;

  })(Node);

  Value = (function(_super) {
    __extends(Value, _super);

    function Value(_value) {
      this._value = _value;
    }

    Value.prototype._check = function(_arg) {
      var obj, path;
      path = _arg.path, obj = _arg.obj;
      if (obj !== this._value) {
        return mkerr(path, "must be set to value " + this._value);
      }
      return null;
    };

    return Value;

  })(Node);

  LinkType = (function(_super) {
    __extends(LinkType, _super);

    function LinkType() {
      return LinkType.__super__.constructor.apply(this, arguments);
    }

    LinkType.prototype._check = function(_arg) {
      var obj, path;
      path = _arg.path, obj = _arg.obj;
      if (!parse.is_link_type(obj)) {
        return mkerr(path, "value must be a valid link type");
      }
      return null;
    };

    return LinkType;

  })(Node);

  PtkType = (function(_super) {
    __extends(PtkType, _super);

    function PtkType() {
      return PtkType.__super__.constructor.apply(this, arguments);
    }

    PtkType.prototype._check = function(_arg) {
      var obj, path;
      path = _arg.path, obj = _arg.obj;
      if (!parse.is_ptk_type(obj)) {
        return mkerr(path, "value must be a PTK type");
      }
      return null;
    };

    return PtkType;

  })(Node);

  Bool = (function(_super) {
    __extends(Bool, _super);

    function Bool() {
      return Bool.__super__.constructor.apply(this, arguments);
    }

    Bool.prototype._check = function(_arg) {
      var obj, path;
      path = _arg.path, obj = _arg.obj;
      if (!parse.is_bool(obj)) {
        return mkerr(path, "value must be a boolean");
      }
      return null;
    };

    return Bool;

  })(Node);

  Or = (function(_super) {
    __extends(Or, _super);

    function Or(_arg) {
      var terms;
      terms = _arg.terms;
      this._terms = terms;
    }

    Or.prototype._check = function(_arg) {
      var obj, ok, path, t, _i, _len, _ref;
      path = _arg.path, obj = _arg.obj;
      ok = false;
      _ref = this._terms;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        if (!(t.check(obj))) {
          continue;
        }
        ok = true;
        break;
      }
      if (!ok) {
        return mkerr(path, "no structure worked");
      }
      return null;
    };

    return Or;

  })(Node);

  Object = (function(_super) {
    __extends(Object, _super);

    function Object() {
      return Object.__super__.constructor.apply(this, arguments);
    }

    Object.prototype._check = function(_arg) {
      var obj, path;
      path = _arg.path, obj = _arg.obj;
      return null;
    };

    return Object;

  })(Node);

  exports.dict = function(keys) {
    return new Dict({
      keys: keys
    });
  };

  exports.binary = function(l, bottom_bytes) {
    return new Binary({
      len: l,
      bottom_bytes: bottom_bytes
    });
  };

  exports.uid = function() {
    return new Binary({
      len: 16,
      bottom_bytes: [0x19, 0x00]
    });
  };

  exports.sig_id = function() {
    return new Binary({
      len: 33,
      bottom_bytes: [0x0f, 0x22]
    });
  };

  exports.hash = function() {
    return new Binary({
      len: 32
    });
  };

  exports.kid = function() {
    return new KID({
      encryption: false
    });
  };

  exports.enc_kid = function() {
    return new KID({
      encryption: true
    });
  };

  exports.seqno = function() {
    return new Seqno({});
  };

  exports.time = function() {
    return new Time({});
  };

  exports.int = function() {
    return new Int({});
  };

  exports.chain_type = function() {
    return new ChainType({});
  };

  exports.link_type = function() {
    return new LinkType({});
  };

  exports.string = function(args) {
    return new String({
      args: args
    });
  };

  exports.value = function(v) {
    return new Value(v);
  };

  exports.bool = function() {
    return new Bool({});
  };

  exports.struct = function(s) {
    return new Struct({
      slots: s
    });
  };

  exports.obj = function() {
    return new Object({});
  };

  exports.array = function(elem) {
    return new Array({
      elem: elem
    });
  };

  exports.ptk_type = function() {
    return new PtkType({});
  };

  exports.string_enum = function(v) {
    return new StringEnum({
      values: v
    });
  };

  exports.or = function(terms) {
    return new Or({
      terms: terms
    });
  };

}).call(this);
