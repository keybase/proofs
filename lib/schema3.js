// Generated by IcedCoffeeScript 108.0.11
(function() {
  var Binary, ChainType, Dict, KID, Node, Path, Seqno, String, Time, mkerr, parse,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  parse = require('./parse3');

  mkerr = function(path, err) {
    return new Error("At " + (path.toString()) + ": " + err);
  };

  Path = (function() {
    function Path(v) {
      this._v = v || [];
    }

    Path.prototype.extend = function(e) {
      return new Path(this._v.concat([e]));
    };

    Path.prototype.toString = function() {
      return this._v.join(".");
    };

    Path.top = function() {
      return new Path(["<top>"]);
    };

    return Path;

  })();

  Node = (function() {
    function Node(_arg) {
      _arg;
      this._optional = false;
      this._name = "";
      this._path = [];
    }

    Node.prototype.optional = function() {
      this._optional = true;
      return this;
    };

    Node.prototype.is_optional = function() {
      return this._optional;
    };

    Node.prototype.name = function(n) {
      this._name = n;
      return this;
    };

    Node.prototype._check = function(_arg) {
      var obj, path;
      path = _arg.path, obj = _arg.obj;
      return mkerr(path, "internal error, no checker found");
    };

    Node.prototype.check = function(obj) {
      return this._check({
        path: Path.top(),
        obj: obj
      });
    };

    return Node;

  })();

  Dict = (function(_super) {
    __extends(Dict, _super);

    function Dict(_arg) {
      var keys;
      keys = _arg.keys;
      this._keys = keys;
      Dict.__super__.constructor.apply(this, arguments);
    }

    Dict.prototype._check = function(_arg) {
      var checker, err, k, new_path, obj, path, v, _ref;
      path = _arg.path, obj = _arg.obj;
      if (typeof obj !== 'object' || Array.isArray(obj)) {
        return mkerr(path, "need a dictionary");
      }
      for (k in obj) {
        v = obj[k];
        new_path = path.extend(k);
        if ((checker = this._keys[k]) == null) {
          return mkerr(new_path, "key is not supported");
        }
        if ((err = checker._check({
          path: new_path,
          obj: v
        })) != null) {
          return err;
        }
      }
      _ref = this._keys;
      for (k in _ref) {
        v = _ref[k];
        new_path = path.extend(k);
        if ((obj[k] == null) && !v.is_optional()) {
          return mkerr(new_path, "key is missing but is mandatory");
        }
      }
      return null;
    };

    Dict.prototype.set_key = function(k, v) {
      return this._keys[k] = v;
    };

    return Dict;

  })(Node);

  Binary = (function(_super) {
    __extends(Binary, _super);

    function Binary(_arg) {
      var len;
      len = _arg.len;
      this._len = len;
    }

    Binary.prototype._check = function(_arg) {
      var obj, path;
      path = _arg.path, obj = _arg.obj;
      if (!(Buffer.isBuffer(obj) && obj.length === this._len)) {
        return mkerr(path, "value needs to be buffer of length " + this._len);
      }
      return null;
    };

    return Binary;

  })(Node);

  KID = (function(_super) {
    __extends(KID, _super);

    function KID(_arg) {
      var encryption;
      encryption = _arg.encryption;
      this._encryption = encryption;
      this._len = 35;
    }

    KID.prototype._check = function(_arg) {
      var err, obj, path, typ;
      path = _arg.path, obj = _arg.obj;
      if ((err = KID.__super__._check.call(this, {
        path: path,
        obj: obj
      })) != null) {
        return err;
      }
      typ = this._encryption ? 0x21 : 0x20;
      if (obj[0] !== 0x01 || obj[1] !== typ || obj.slice(-1)[0] !== 0x0a) {
        return mkerr(path, "value must be a KID" + (this._encryption ? ' (for encryption)' : ''));
      }
      return null;
    };

    return KID;

  })(Binary);

  Seqno = (function(_super) {
    __extends(Seqno, _super);

    function Seqno() {
      return Seqno.__super__.constructor.apply(this, arguments);
    }

    Seqno.prototype._check = function(_arg) {
      var obj, path;
      path = _arg.path, obj = _arg.obj;
      if (!parse.is_seqno(obj)) {
        return mkerr(path, "value must be a seqno (sequence number)");
      }
      return null;
    };

    return Seqno;

  })(Node);

  Time = (function(_super) {
    __extends(Time, _super);

    function Time() {
      return Time.__super__.constructor.apply(this, arguments);
    }

    Time.prototype._check = function(_arg) {
      var obj, path;
      path = _arg.path, obj = _arg.obj;
      if (!parse.is_time(obj)) {
        return mkerr(path, "value must be a UTC timestamp");
      }
      return null;
    };

    return Time;

  })(Node);

  ChainType = (function(_super) {
    __extends(ChainType, _super);

    function ChainType() {
      return ChainType.__super__.constructor.apply(this, arguments);
    }

    ChainType.prototype._check = function(_arg) {
      var obj, path;
      path = _arg.path, obj = _arg.obj;
      if (!parse.is_chain_type(obj)) {
        return mkerr(path, "value must be a valid chain type");
      }
      return null;
    };

    return ChainType;

  })(Node);

  String = (function(_super) {
    __extends(String, _super);

    function String() {
      return String.__super__.constructor.apply(this, arguments);
    }

    String.prototype._check = function(_arg) {
      var obj, path;
      path = _arg.path, obj = _arg.obj;
      if (typeof obj !== 'string' || obj.length === 0) {
        return mkerr(path, "value must be a string");
      }
      return null;
    };

    return String;

  })(Node);

  exports.dict = function(keys) {
    return new Dict({
      keys: keys
    });
  };

  exports.binary = function(l) {
    return new Binary({
      len: l
    });
  };

  exports.uid = function() {
    return new Binary({
      len: 16
    });
  };

  exports.kid = function() {
    return new KID({
      encryption: false
    });
  };

  exports.enc_kid = function() {
    return new KID({
      encryption: true
    });
  };

  exports.seqno = function() {
    return new Seqno({});
  };

  exports.time = function() {
    return new Time({});
  };

  exports.uid = function() {
    return new Binary({
      len: 16
    });
  };

  exports.chain_type = function() {
    return new ChainType({});
  };

  exports.string = function() {
    return new String({});
  };

}).call(this);
