// Generated by IcedCoffeeScript 108.0.11
(function() {
  var Base, KeyManager, OuterLink, bufferify, constants, crypto, errors, iced, kbpgp, make_esc, pack, parse, pgp_utils, schema, sha256, unix_time, unpack, __iced_k, __iced_k_noop, _encode_dict, _pack, _ref, _ref1;

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  kbpgp = require('kbpgp');

  _ref = require('purepack'), pack = _ref.pack, unpack = _ref.unpack;

  errors = require('./errors').errors;

  crypto = require('crypto');

  make_esc = require('iced-error').make_esc;

  constants = require('./constants').constants;

  _ref1 = require('./util'), bufferify = _ref1.bufferify, sha256 = _ref1.sha256;

  parse = require('./parse3');

  KeyManager = kbpgp.kb.KeyManager;

  pgp_utils = require('pgp-utils');

  unix_time = pgp_utils.util.unix_time;

  schema = require('./schema3');

  _pack = function(obj) {
    return pack(obj, {
      sort_keys: true
    });
  };

  _encode_dict = function(d) {
    var k, ret, v;
    ret = {};
    for (k in d) {
      v = d[k];
      ret[k] = _pack(v).toString('base64');
    }
    return ret;
  };

  exports.OuterLink = OuterLink = (function() {
    function OuterLink(_arg) {
      this.version = _arg.version, this.seqno = _arg.seqno, this.prev = _arg.prev, this.inner_hash = _arg.inner_hash, this.link_type = _arg.link_type, this.chain_type = _arg.chain_type, this.ignore_if_unsupported = _arg.ignore_if_unsupported;
    }

    OuterLink.prototype.encode = function() {
      return [this.version, this.seqno, this.prev, this.inner_hash, this.link_type, this.chain_type, this.ignore_if_unsupported];
    };

    OuterLink.decode = function(obj) {
      var err, schm;
      schm = schema.array([schema.value(3).name("version"), schema.seqno().name("seqno"), schema.binary(32).name("prev").optional(), schema.binary(32).name("inner_link"), schema.link_type().name("link_type"), schema.chain_type().name("chain_type"), schema.bool().name("ignore_if_unsupported")]).name("outer");
      if ((err = schm.check(obj)) != null) {
        return [err, null];
      }
      return [
        null, new OuterLink({
          version: obj[0],
          seqno: obj[1],
          prev: obj[2],
          inner_hash: obj[3],
          link_type: obj[4],
          chain_type: obj[5],
          ignore_if_unsupported: obj[6]
        })
      ];
    };

    return OuterLink;

  })();

  exports.Base = Base = (function() {
    function Base(_arg) {
      this.sig_eng = _arg.sig_eng, this.seqno = _arg.seqno, this.user = _arg.user, this.prev = _arg.prev, this.client = _arg.client, this.merkle_root = _arg.merkle_root, this.ignore_if_unsupported = _arg.ignore_if_unsupported, this.ctime = _arg.ctime, this.entropy = _arg.entropy, this.public_chain_tail = _arg.public_chain_tail, this.new_sig_km = _arg.new_sig_km;
    }

    Base.prototype._generate_inner = function(opts, cb) {
      var esc, json;
      esc = make_esc(cb);
      json = this._encode_inner(opts);
      opts.json = json;
      this._v_encode_inner(opts);
      delete opts.json;
      return cb(null, json);
    };

    Base.prototype._version = function() {
      return constants.versions.sig_v3;
    };

    Base.prototype._v_generate_inner = function(_arg) {
      var obj;
      obj = _arg.obj;
    };

    Base.prototype._v_do_reverse_sign = function() {
      return false;
    };

    Base.prototype._v_assign_reverse_sig = function() {};

    Base.prototype._v_new_sig_km = function() {
      return null;
    };

    Base.prototype._v_link_type_v3 = function() {
      throw new Error("unimplemented");
    };

    Base.prototype._v_chain_type_v3 = function() {
      throw new Error("unimplemented");
    };

    Base.prototype._get_reverse_sig = function() {
      throw new Error("unimplemented");
    };

    Base.prototype._assign_outer = function(_arg) {
      var outer_obj;
      outer_obj = _arg.outer_obj;
      this.seqno = outer_obj.seqno;
      this.prev = outer_obj.prev;
      return this.ignore_if_unsupported = outer_obj.ignore_if_unsupported;
    };

    Base.prototype._enforce_schema = function(_arg, cb) {
      var json, schm;
      json = _arg.json;
      schm = schema.dict({
        c: schema.time().name("ctime"),
        e: schema.binary(16).name("entropy"),
        m: schema.dict({
          c: schema.time().name("ctime"),
          h: schema.binary(32).name("hash_meta"),
          s: schema.seqno().name("seqno")
        }).name("merkle_root"),
        s: schema.dict({
          e: schema.seqno().name("eldest_seqno"),
          k: schema.kid().name("kid"),
          u: schema.uid().name("uid")
        }).name("signer"),
        p: schema.dict({
          h: schema.binary(32).name("tail"),
          s: schema.seqno().name("seqno"),
          t: schema.chain_type().name("chain_type")
        }).optional().name("public_chain_tail"),
        i: schema.dict({
          d: schema.string().name("description"),
          v: schema.string().name("version")
        }).optional().name("client_info")
      }).name("inner");
      this._v_extend_schema(schm);
      return cb(schm.check(json));
    };

    Base.prototype.decode_inner = function(_arg, cb) {
      var esc, json, km, outer_obj, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      json = _arg.json, outer_obj = _arg.outer_obj;
      esc = make_esc(cb);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
            funcname: "Base.decode_inner"
          });
          _this._enforce_schema({
            json: json
          }, esc(__iced_deferrals.defer({
            lineno: 121
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          _this._assign_outer({
            outer_obj: outer_obj
          });
          _this.ctime = json.c;
          _this.entropy = json.e;
          _this.merkle_root = {
            ctime: json.m.c,
            hash_meta: json.m.h,
            seqno: json.m.s
          };
          _this.user = {
            local: {
              uid: json.s.u,
              eldest_seqno: json.s.e
            }
          };
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
              funcname: "Base.decode_inner"
            });
            KeyManager.import_public({
              raw: json.s.k
            }, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return km = arguments[0];
                };
              })(),
              lineno: 133
            })));
            __iced_deferrals._fulfill();
          })(function() {
            _this.sig_eng = km.make_sig_eng();
            if (json.p != null) {
              _this.public_chain_tail = {
                hash: json.p.h,
                seqno: json.p.s,
                chain_type: json.p.t
              };
            }
            if (json.i != null) {
              _this.client = {
                name: json.i.d,
                version: json.i.v
              };
            }
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
                funcname: "Base.decode_inner"
              });
              _this._v_decode_inner({
                json: json
              }, esc(__iced_deferrals.defer({
                lineno: 146
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(null);
            });
          });
        };
      })(this));
    };

    Base.prototype._encode_inner = function(opts) {
      return this._encode_inner_impl(opts);
    };

    Base.prototype._encode_inner_impl = function(opts) {
      var entropy, json, p;
      entropy = this.entropy || crypto.prng(16);
      json = {
        c: this.ctime,
        e: entropy,
        m: {
          c: this.merkle_root.ctime,
          h: parse.unhex(this.merkle_root.hash_meta),
          s: this.merkle_root.seqno
        },
        s: {
          e: this.user.local.eldest_seqno,
          k: this.sig_eng.get_km().key.ekid(),
          u: parse.unhex(this.user.local.uid)
        }
      };
      if ((p = this.public_chain_tail) != null) {
        json.p = {
          h: parse.unhex(p.hash),
          s: p.seqno,
          t: p.chain_type
        };
      }
      if (this.client != null) {
        json.i = {
          d: this.client.name,
          v: this.client.version
        };
      }
      return json;
    };

    Base.prototype._prefix = function() {
      return bufferify(constants.sig_prefixes[this._version()]);
    };

    Base.prototype._sign = function(_arg, cb) {
      var esc, outer, payload, res, sig_eng, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      sig_eng = _arg.sig_eng, outer = _arg.outer;
      esc = make_esc(cb);
      payload = _pack(outer);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
            funcname: "Base._sign"
          });
          sig_eng.box(payload, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return res = arguments[0];
              };
            })(),
            lineno: 181
          })), {
            prefix: _this._prefix()
          });
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(null, res.sig);
        };
      })(this));
    };

    Base.prototype._hash = function(inner) {
      return sha256(_pack(inner));
    };

    Base.prototype._reverse_sign = function(_arg, cb) {
      var esc, inner, k, outer, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      inner = _arg.inner, outer = _arg.outer;
      esc = make_esc(cb);
      if (!this._v_do_reverse_sign()) {
        return cb(null, {
          inner: inner,
          outer: outer
        });
      }
      if ((k = this._v_new_sig_km()) == null) {
        return cb(new Error("need a new_sig_km if doing a reverse signature"));
      }
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
            funcname: "Base._reverse_sign"
          });
          _this._sign({
            sig_eng: k.make_sig_eng(),
            outer: outer
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return sig = arguments[0];
              };
            })(),
            lineno: 192
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          _this._v_assign_reverse_sig({
            sig: sig,
            inner: inner
          });
          outer = _this._generate_outer({
            inner: inner
          });
          return cb(null, {
            inner: inner,
            outer: outer
          });
        };
      })(this));
    };

    Base.prototype.verify_reverse_sig = function(_arg, cb) {
      var esc, inner, inner_hash, k, outer, outer_obj, payload, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      inner = _arg.inner, outer_obj = _arg.outer_obj;
      esc = make_esc(cb);
      if (!this._v_do_reverse_sign()) {
        return cb(null);
      }
      if ((k = this._v_new_sig_km()) == null) {
        return cb(new Error("need a new_sig_km if checking a reverse signature"));
      }
      sig = this._v_get_reverse_sig({
        inner: inner
      });
      this._v_assign_reverse_sig({
        sig: null,
        inner: inner
      });
      inner_hash = outer_obj.inner_hash;
      outer_obj.inner_hash = this._hash(inner);
      outer = outer_obj.encode();
      outer_obj.inner_hash = inner_hash;
      this._v_assign_reverse_sig({
        sig: sig,
        inner: inner
      });
      payload = _pack(outer);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
            funcname: "Base.verify_reverse_sig"
          });
          k.verify_raw({
            prefix: _this._prefix(),
            payload: payload,
            sig: sig
          }, esc(__iced_deferrals.defer({
            lineno: 211
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(null);
        };
      })(this));
    };

    Base.prototype.check = function(_arg, cb) {
      var esc, now, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      now = _arg.now;
      esc = make_esc(cb);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
            funcname: "Base.check"
          });
          _this._check_clock_skew({
            now: now
          }, esc(__iced_deferrals.defer({
            lineno: 216
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(null);
        };
      })(this));
    };

    Base.prototype._check_clock_skew = function(_arg, cb) {
      var critical_clock_skew_secs, diff, epoch, err, now;
      now = _arg.now;
      critical_clock_skew_secs = constants.critical_clock_skew_secs;
      now || (now = unix_time());
      diff = Math.abs(now - this.ctime);
      if (Math.abs(diff) > critical_clock_skew_secs) {
        epoch = now > this.ctime ? "past" : "future";
        err = new errors.ClockSkewError("your computer's clock is wrong: signature is dated " + diff + " seconds in the " + epoch);
        err.diff = diff;
      }
      return cb(err);
    };

    Base.prototype._generate_outer = function(_arg) {
      var inner;
      inner = _arg.inner;
      return (new OuterLink({
        version: this._version(),
        seqno: this.seqno,
        prev: parse.unhex(this.prev),
        inner_hash: this._hash(inner),
        link_type: this._v_link_type_v3(),
        chain_type: this._v_chain_type_v3(),
        ignore_if_unsupported: this.ignore_if_unsupported
      })).encode();
    };

    Base.prototype.generate = function(opts, cb) {
      var armored, esc, inner, outer, raw, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
            funcname: "Base.generate"
          });
          _this._generate_inner(opts, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return inner = arguments[0];
              };
            })(),
            lineno: 242
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          outer = _this._generate_outer({
            inner: inner
          });
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
              funcname: "Base.generate"
            });
            _this._reverse_sign({
              inner: inner,
              outer: outer
            }, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  inner = arguments[0].inner;
                  return outer = arguments[0].outer;
                };
              })(),
              lineno: 244
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
                funcname: "Base.generate"
              });
              _this._sign({
                sig_eng: _this.sig_eng,
                outer: outer
              }, esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return sig = arguments[0];
                  };
                })(),
                lineno: 245
              })));
              __iced_deferrals._fulfill();
            })(function() {
              raw = {
                outer: outer,
                inner: inner,
                sig: sig
              };
              armored = _encode_dict(raw);
              return cb(null, {
                raw: raw,
                armored: armored
              });
            });
          });
        };
      })(this));
    };

    return Base;

  })();

}).call(this);
