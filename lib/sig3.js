// Generated by IcedCoffeeScript 108.0.11
(function() {
  var Base, KeyManager, OuterLink, bufferify, constants, crypto, errors, iced, kbpgp, make_esc, pack, parse, pgp_utils, sha256, unix_time, unpack, __iced_k, __iced_k_noop, _encode_dict, _pack, _ref, _ref1;

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  kbpgp = require('kbpgp');

  _ref = require('purepack'), pack = _ref.pack, unpack = _ref.unpack;

  errors = require('./errors').errors;

  crypto = require('crypto');

  make_esc = require('iced-error').make_esc;

  constants = require('./constants').constants;

  _ref1 = require('./util'), bufferify = _ref1.bufferify, sha256 = _ref1.sha256;

  parse = require('./parse3');

  KeyManager = kbpgp.kb.KeyManager;

  pgp_utils = require('pgp-utils');

  unix_time = pgp_utils.util.unix_time;

  _pack = function(obj) {
    return pack(obj, {
      sort_keys: true
    });
  };

  _encode_dict = function(d) {
    var k, ret, v;
    ret = {};
    for (k in d) {
      v = d[k];
      ret[k] = _pack(v).toString('base64');
    }
    return ret;
  };

  exports.OuterLink = OuterLink = (function() {
    function OuterLink(_arg) {
      this.version = _arg.version, this.seqno = _arg.seqno, this.prev = _arg.prev, this.inner_hash = _arg.inner_hash, this.link_type = _arg.link_type, this.chain_type = _arg.chain_type, this.ignore_if_unsupported = _arg.ignore_if_unsupported;
    }

    OuterLink.prototype.encode = function() {
      return [this.version, this.seqno, this.prev, this.inner_hash, this.link_type, this.chain_type, this.ignore_if_unsupported];
    };

    OuterLink.decode = function(obj) {
      var e;
      e = function(s) {
        return [new Error(s), null];
      };
      if (!(typeof obj === 'object' && Array.isArray(obj))) {
        return e("outer links must be arrays");
      }
      if (obj.length !== 7) {
        return e("outer links must be len 7");
      }
      if (obj[0] !== constants.versions.sig_v3) {
        return e("outer link slot 0 must be version 3");
      }
      if (!parse.is_seqno(obj[1])) {
        return e("outer link slot 1 must be a seqno");
      }
      if (!parse.is_prev(obj[2])) {
        return e("outer link slot 2 must be a prev");
      }
      if (!parse.is_inner_link_hash(obj[3])) {
        return e("outer link slot 3 must be an innerlink hash");
      }
      if (!parse.is_link_type(obj[4])) {
        return e("outer link slot 4 must be a link type");
      }
      if (!parse.is_chain_type(obj[5])) {
        return e("outer link slot 5 must be a chain type");
      }
      if (!parse.is_bool(obj[6])) {
        return e("outer link slot 6 must be a boolean");
      }
      return [
        null, new OuterLink({
          version: obj[0],
          seqno: obj[1],
          prev: obj[2],
          inner_hash: obj[3],
          link_type: obj[4],
          chain_type: obj[5],
          ignore_if_unsupported: obj[6]
        })
      ];
    };

    return OuterLink;

  })();

  exports.Base = Base = (function() {
    function Base(_arg) {
      this.sig_eng = _arg.sig_eng, this.seqno = _arg.seqno, this.user = _arg.user, this.prev = _arg.prev, this.client = _arg.client, this.merkle_root = _arg.merkle_root, this.ignore_if_unsupported = _arg.ignore_if_unsupported, this.ctime = _arg.ctime, this.entropy = _arg.entropy, this.public_chain_tail = _arg.public_chain_tail, this.new_sig_km = _arg.new_sig_km;
    }

    Base.prototype._generate_inner = function(opts, cb) {
      var esc, json;
      esc = make_esc(cb);
      json = this._encode_inner(opts);
      opts.json = json;
      this._v_encode_inner(opts);
      delete opts.json;
      return cb(null, json);
    };

    Base.prototype._version = function() {
      return constants.versions.sig_v3;
    };

    Base.prototype._v_generate_inner = function(_arg) {
      var obj;
      obj = _arg.obj;
    };

    Base.prototype._v_do_reverse_sign = function() {
      return false;
    };

    Base.prototype._v_assign_reverse_sig = function() {};

    Base.prototype._v_new_sig_km = function() {
      return null;
    };

    Base.prototype._v_link_type_v3 = function() {
      throw new Error("unimplemented");
    };

    Base.prototype._v_chain_type_v3 = function() {
      throw new Error("unimplemented");
    };

    Base.prototype._get_reverse_sig = function() {
      throw new Error("unimplemented");
    };

    Base.prototype._assign_outer = function(_arg) {
      var outer_obj;
      outer_obj = _arg.outer_obj;
      this.seqno = outer_obj.seqno;
      this.prev = outer_obj.prev;
      return this.ignore_if_unsupported = outer_obj.ignore_if_unsupported;
    };

    Base.prototype.decode_inner = function(_arg, cb) {
      var e, err, esc, json, km, outer_obj, p, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      json = _arg.json, outer_obj = _arg.outer_obj;
      esc = make_esc(cb);
      e = function(m) {
        return new Error(m);
      };
      p = function() {
        if (!parse.is_time(json.c)) {
          return e("need a time for c");
        }
        if (!parse.is_hex(json.e, 16)) {
          return e("need 16-byte entropy");
        }
        if (!((json.m != null) && parse.is_dict(json.m))) {
          return e("need a merkle root");
        }
        if (!parse.is_time(json.m.c)) {
          return e("m.c must be a time");
        }
        if (!parse.is_hex(json.m.h, 32)) {
          return e("m.h must be a 32-byte hash");
        }
        if (!parse.is_seqno(json.m.s)) {
          return e("m.s must be a seqno");
        }
        if (!((json.s != null) && parse.is_dict(json.s))) {
          return e("need a signer for s");
        }
        if (!parse.is_seqno(json.s.e)) {
          return e("need a seqno for s.e");
        }
        if (!parse.is_kid(json.s.k)) {
          return e("need a kid for s.k");
        }
        if (!parse.is_uid(json.s.u)) {
          return e("need a uid for s.u");
        }
        if (json.p != null) {
          if (!parse.is_hex(json.p.h, 32)) {
            return e("need a hash for p.h");
          }
          if (!parse.is_seqno(json.p.s)) {
            return e("need a seqno for p.s");
          }
          if (!parse.is_chain_type(json.p.t)) {
            return e("need a chain type for p.t");
          }
        }
        return null;
      };
      err = p();
      if (err != null) {
        return cb(err);
      }
      this._assign_outer({
        outer_obj: outer_obj
      });
      this.ctime = json.c;
      this.entropy = json.e;
      this.merkle_root = {
        ctime: json.m.c,
        hash_meta: json.m.h,
        seqno: json.m.s
      };
      this.user = {
        local: {
          uid: json.s.u,
          eldest_seqno: json.s.e
        }
      };
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
            funcname: "Base.decode_inner"
          });
          KeyManager.import_public({
            raw: json.s.k
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return km = arguments[0];
              };
            })(),
            lineno: 122
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          _this.sig_eng = km.make_sig_eng();
          if (json.p != null) {
            _this.public_chain_tail = {
              hash: json.p.h,
              seqno: json.p.s,
              chain_type: json.p.t
            };
          }
          if (json.i != null) {
            _this.client = {
              name: json.i.d,
              version: json.i.v
            };
          }
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
              funcname: "Base.decode_inner"
            });
            _this._v_decode_inner({
              json: json
            }, esc(__iced_deferrals.defer({
              lineno: 135
            })));
            __iced_deferrals._fulfill();
          })(function() {
            return cb(null);
          });
        };
      })(this));
    };

    Base.prototype._encode_inner = function(opts) {
      return this._encode_inner_impl(opts);
    };

    Base.prototype._encode_inner_impl = function(opts) {
      var entropy, json, p;
      entropy = this.entropy || crypto.prng(16);
      json = {
        c: this.ctime,
        e: entropy,
        m: {
          c: this.merkle_root.ctime,
          h: parse.unhex(this.merkle_root.hash_meta),
          s: this.merkle_root.seqno
        },
        s: {
          e: this.user.local.eldest_seqno,
          k: this.sig_eng.get_km().key.ekid(),
          u: parse.unhex(this.user.local.uid)
        }
      };
      if ((p = this.public_chain_tail) != null) {
        json.p = {
          h: parse.unhex(p.hash),
          s: p.seqno,
          t: p.chain_type
        };
      }
      if (this.client != null) {
        json.i = {
          d: this.client.name,
          v: this.client.version
        };
      }
      return json;
    };

    Base.prototype._prefix = function() {
      return bufferify(constants.sig_prefixes[this._version()]);
    };

    Base.prototype._sign = function(_arg, cb) {
      var esc, outer, payload, res, sig_eng, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      sig_eng = _arg.sig_eng, outer = _arg.outer;
      esc = make_esc(cb);
      payload = _pack(outer);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
            funcname: "Base._sign"
          });
          sig_eng.box(payload, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return res = arguments[0];
              };
            })(),
            lineno: 170
          })), {
            prefix: _this._prefix()
          });
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(null, res.sig);
        };
      })(this));
    };

    Base.prototype._hash = function(inner) {
      return sha256(_pack(inner));
    };

    Base.prototype._reverse_sign = function(_arg, cb) {
      var esc, inner, k, outer, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      inner = _arg.inner, outer = _arg.outer;
      esc = make_esc(cb);
      if (!this._v_do_reverse_sign()) {
        return cb(null, {
          inner: inner,
          outer: outer
        });
      }
      if ((k = this._v_new_sig_km()) == null) {
        return cb(new Error("need a new_sig_km if doing a reverse signature"));
      }
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
            funcname: "Base._reverse_sign"
          });
          _this._sign({
            sig_eng: k.make_sig_eng(),
            outer: outer
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return sig = arguments[0];
              };
            })(),
            lineno: 181
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          _this._v_assign_reverse_sig({
            sig: sig,
            inner: inner
          });
          outer = _this._generate_outer({
            inner: inner
          });
          return cb(null, {
            inner: inner,
            outer: outer
          });
        };
      })(this));
    };

    Base.prototype.verify_reverse_sig = function(_arg, cb) {
      var esc, inner, inner_hash, k, outer, outer_obj, payload, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      inner = _arg.inner, outer_obj = _arg.outer_obj;
      esc = make_esc(cb);
      if (!this._v_do_reverse_sign()) {
        return cb(null);
      }
      if ((k = this._v_new_sig_km()) == null) {
        return cb(new Error("need a new_sig_km if checking a reverse signature"));
      }
      sig = this._v_get_reverse_sig({
        inner: inner
      });
      this._v_assign_reverse_sig({
        sig: null,
        inner: inner
      });
      inner_hash = outer_obj.inner_hash;
      outer_obj.inner_hash = this._hash(inner);
      outer = outer_obj.encode();
      outer_obj.inner_hash = inner_hash;
      this._v_assign_reverse_sig({
        sig: sig,
        inner: inner
      });
      payload = _pack(outer);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
            funcname: "Base.verify_reverse_sig"
          });
          k.verify_raw({
            prefix: _this._prefix(),
            payload: payload,
            sig: sig
          }, esc(__iced_deferrals.defer({
            lineno: 200
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(null);
        };
      })(this));
    };

    Base.prototype.check = function(_arg, cb) {
      var esc, now, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      now = _arg.now;
      esc = make_esc(cb);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
            funcname: "Base.check"
          });
          _this._check_clock_skew({
            now: now
          }, esc(__iced_deferrals.defer({
            lineno: 205
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(null);
        };
      })(this));
    };

    Base.prototype._check_clock_skew = function(_arg, cb) {
      var critical_clock_skew_secs, diff, epoch, err, now;
      now = _arg.now;
      critical_clock_skew_secs = constants.critical_clock_skew_secs;
      now || (now = unix_time());
      diff = Math.abs(now - this.ctime);
      if (Math.abs(diff) > critical_clock_skew_secs) {
        epoch = now > this.ctime ? "past" : "future";
        err = new errors.ClockSkewError("your computer's clock is wrong: signature is dated " + diff + " seconds in the " + epoch);
        err.diff = diff;
      }
      return cb(err);
    };

    Base.prototype._generate_outer = function(_arg) {
      var inner;
      inner = _arg.inner;
      return (new OuterLink({
        version: this._version(),
        seqno: this.seqno,
        prev: parse.unhex(this.prev),
        inner_hash: this._hash(inner),
        link_type: this._v_link_type_v3(),
        chain_type: this._v_chain_type_v3(),
        ignore_if_unsupported: this.ignore_if_unsupported
      })).encode();
    };

    Base.prototype.generate = function(opts, cb) {
      var armored, esc, inner, outer, raw, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
            funcname: "Base.generate"
          });
          _this._generate_inner(opts, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return inner = arguments[0];
              };
            })(),
            lineno: 231
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          outer = _this._generate_outer({
            inner: inner
          });
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
              funcname: "Base.generate"
            });
            _this._reverse_sign({
              inner: inner,
              outer: outer
            }, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  inner = arguments[0].inner;
                  return outer = arguments[0].outer;
                };
              })(),
              lineno: 233
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/proofs/src/sig3.iced",
                funcname: "Base.generate"
              });
              _this._sign({
                sig_eng: _this.sig_eng,
                outer: outer
              }, esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return sig = arguments[0];
                  };
                })(),
                lineno: 234
              })));
              __iced_deferrals._fulfill();
            })(function() {
              raw = {
                outer: outer,
                inner: inner,
                sig: sig
              };
              armored = _encode_dict(raw);
              return cb(null, {
                raw: raw,
                armored: armored
              });
            });
          });
        };
      })(this));
    };

    return Base;

  })();

}).call(this);
