// Generated by IcedCoffeeScript 108.0.11
(function() {
  var Base, KeyManager, OuterLink, bufferify, constants, crypto, errors, iced, kbpgp, make_esc, pack, parse, pgp_utils, schema, sha256, unix_time, unpack, __iced_k, __iced_k_noop, _encode_dict, _ref;

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  kbpgp = require('kbpgp');

  unpack = require('purepack').unpack;

  errors = require('./errors').errors;

  crypto = require('crypto');

  make_esc = require('iced-error').make_esc;

  constants = require('./constants').constants;

  _ref = require('./util'), pack = _ref.pack, bufferify = _ref.bufferify, sha256 = _ref.sha256;

  parse = require('./parse3');

  KeyManager = kbpgp.kb.KeyManager;

  pgp_utils = require('pgp-utils');

  unix_time = pgp_utils.util.unix_time;

  schema = require('./schema3');

  _encode_dict = function(d) {
    var k, ret, v;
    ret = {
      armored: {},
      json: {}
    };
    for (k in d) {
      v = d[k];
      ret.json[k] = pack(v);
      ret.armored[k] = ret.json[k].toString('base64');
    }
    return ret;
  };

  exports.OuterLink = OuterLink = (function() {
    function OuterLink(_arg) {
      this.version = _arg.version, this.seqno = _arg.seqno, this.prev = _arg.prev, this.inner_hash = _arg.inner_hash, this.link_type = _arg.link_type, this.chain_type = _arg.chain_type, this.ignore_if_unsupported = _arg.ignore_if_unsupported, this.encryption_parameters = _arg.encryption_parameters;
    }

    OuterLink.prototype.encode = function() {
      return [this.version, this.seqno, this.prev, this.inner_hash, this.link_type, this.chain_type, this.ignore_if_unsupported, this.encryption_parameters];
    };

    OuterLink.decode = function(obj) {
      var err, schm;
      schm = schema.struct([
        schema.value(3).name("version"), schema.seqno().name("seqno"), schema.binary(32).name("prev").optional(), schema.binary(32).name("inner_link"), schema.link_type().name("link_type"), schema.chain_type().name("chain_type"), schema.bool().name("ignore_if_unsupported"), schema.dict({
          k: schema.enc_kid().name("kid"),
          n: schema.binary(24).name("nonce"),
          v: schema.int().name("version")
        }).optional().name("encryption_parameters")
      ]).name("outer");
      if ((err = schm.check(obj)) != null) {
        return [err, null];
      }
      return [
        null, new OuterLink({
          version: obj[0],
          seqno: obj[1],
          prev: obj[2],
          inner_hash: obj[3],
          link_type: obj[4],
          chain_type: obj[5],
          ignore_if_unsupported: obj[6],
          encryption_parameters: obj[7]
        })
      ];
    };

    OuterLink.prototype.check = function(opts, cb) {
      var err;
      err = null;
      if (!((this.chain_type === constants.seq_types.TEAM_HIDDEN) && (this.link_type === constants.sig_types_v3.team.rotate_key))) {
        err = new Error("bad chain/link type combo");
      }
      return cb(err);
    };

    return OuterLink;

  })();

  exports.Base = Base = (function() {
    function Base(_arg) {
      this.sig_eng = _arg.sig_eng, this.seqno = _arg.seqno, this.user = _arg.user, this.prev = _arg.prev, this.client = _arg.client, this.merkle_root = _arg.merkle_root, this.ignore_if_unsupported = _arg.ignore_if_unsupported, this.ctime = _arg.ctime, this.entropy = _arg.entropy, this.parent_chain_tail = _arg.parent_chain_tail;
    }

    Base.prototype._generate_inner = function(opts, cb) {
      return this._generate_inner_impl(opts, cb);
    };

    Base.prototype._generate_inner_impl = function(opts, cb) {
      var esc, json;
      esc = make_esc(cb);
      json = this._encode_inner(opts);
      opts.json = json;
      this._v_encode_inner(opts);
      delete opts.json;
      return cb(null, json);
    };

    Base.prototype._version = function() {
      return constants.versions.sig_v3;
    };

    Base.prototype._v_generate_inner = function(_arg) {
      var obj;
      obj = _arg.obj;
    };

    Base.prototype._v_new_sig_km = function() {
      return null;
    };

    Base.prototype._v_link_type_v3 = function() {
      throw new Error("unimplemented");
    };

    Base.prototype._v_chain_type_v3 = function() {
      throw new Error("unimplemented");
    };

    Base.prototype._v_reverse_sign = function(_arg, cb) {
      var inner, outer;
      inner = _arg.inner, outer = _arg.outer;
      return cb(null, {
        inner: inner,
        outer: outer
      });
    };

    Base.prototype._v_verify_reverse_sig = function(_arg, cb) {
      var inner, outer_obj;
      inner = _arg.inner, outer_obj = _arg.outer_obj;
      return cb(null);
    };

    Base.prototype._v_assert_is_v2_legacy = function() {
      return null;
    };

    Base.prototype._assign_outer = function(_arg) {
      var outer_obj;
      outer_obj = _arg.outer_obj;
      this.seqno = outer_obj.seqno;
      this.prev = outer_obj.prev;
      return this.ignore_if_unsupported = outer_obj.ignore_if_unsupported;
    };

    Base.prototype._enforce_schema = function(_arg, cb) {
      var json, schm;
      json = _arg.json;
      schm = schema.dict({
        c: schema.time().name("ctime"),
        e: schema.binary(16).name("entropy"),
        m: schema.dict({
          c: schema.time().name("ctime"),
          h: schema.binary(32).name("hash_meta"),
          s: schema.seqno().name("seqno")
        }).name("merkle_root"),
        s: schema.dict({
          e: schema.seqno().name("eldest_seqno"),
          k: schema.kid().name("kid"),
          u: schema.uid().name("uid")
        }).name("signer"),
        p: schema.dict({
          h: schema.binary(32).name("tail"),
          s: schema.seqno().name("seqno"),
          t: schema.chain_type().name("chain_type")
        }).optional().name("parent_chain_tail"),
        i: schema.dict({
          d: schema.string().name("description"),
          v: schema.string().name("version")
        }).optional().name("client_info")
      }).name("inner");
      this._v_extend_schema(schm);
      return cb(schm.check(json));
    };

    Base.prototype.decode_inner = function(_arg, cb) {
      var esc, json, km, outer_obj, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      json = _arg.json, outer_obj = _arg.outer_obj;
      esc = make_esc(cb);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/me/code/src/github.com/keybase/proofs/src/sig3.iced",
            funcname: "Base.decode_inner"
          });
          _this._enforce_schema({
            json: json
          }, esc(__iced_deferrals.defer({
            lineno: 134
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          _this._assign_outer({
            outer_obj: outer_obj
          });
          _this.ctime = json.c;
          _this.entropy = json.e;
          _this.merkle_root = {
            ctime: json.m.c,
            hash_meta: json.m.h,
            seqno: json.m.s
          };
          _this.user = {
            local: {
              uid: json.s.u,
              eldest_seqno: json.s.e
            }
          };
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/home/me/code/src/github.com/keybase/proofs/src/sig3.iced",
              funcname: "Base.decode_inner"
            });
            KeyManager.import_public({
              raw: json.s.k
            }, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return km = arguments[0];
                };
              })(),
              lineno: 146
            })));
            __iced_deferrals._fulfill();
          })(function() {
            _this.sig_eng = km.make_sig_eng();
            if (json.p != null) {
              _this.parent_chain_tail = {
                hash: json.p.h,
                seqno: json.p.s,
                chain_type: json.p.t
              };
            }
            if (json.i != null) {
              _this.client = {
                name: json.i.d,
                version: json.i.v
              };
            }
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/me/code/src/github.com/keybase/proofs/src/sig3.iced",
                funcname: "Base.decode_inner"
              });
              _this._v_decode_inner({
                json: json
              }, esc(__iced_deferrals.defer({
                lineno: 159
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(null);
            });
          });
        };
      })(this));
    };

    Base.prototype._encode_inner = function(opts) {
      var entropy, json, p;
      entropy = this.entropy || crypto.prng(16);
      json = {
        c: this.ctime,
        e: entropy,
        m: {
          c: this.merkle_root.ctime,
          h: parse.unhex(this.merkle_root.hash_meta),
          s: this.merkle_root.seqno
        },
        s: {
          e: this.user.local.eldest_seqno,
          k: this.sig_eng.get_km().key.ekid(),
          u: parse.unhex(this.user.local.uid)
        }
      };
      if ((p = this.parent_chain_tail) != null) {
        json.p = {
          h: parse.unhex(p.hash),
          s: p.seqno,
          t: p.chain_type
        };
      }
      if (this.client != null) {
        json.i = {
          d: this.client.name,
          v: this.client.version
        };
      }
      return json;
    };

    Base.prototype._prefix = function() {
      return bufferify(constants.sig_prefixes[this._version()]);
    };

    Base.prototype._sign = function(_arg, cb) {
      var esc, outer, payload, res, sig_eng, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      sig_eng = _arg.sig_eng, outer = _arg.outer;
      esc = make_esc(cb);
      payload = pack(outer);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/me/code/src/github.com/keybase/proofs/src/sig3.iced",
            funcname: "Base._sign"
          });
          sig_eng.box(payload, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return res = arguments[0];
              };
            })(),
            lineno: 191
          })), {
            prefix: _this._prefix()
          });
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(null, res.sig);
        };
      })(this));
    };

    Base.prototype._hash = function(inner) {
      return sha256(pack(inner));
    };

    Base.prototype.check = function(_arg, cb) {
      var esc, now, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      now = _arg.now;
      esc = make_esc(cb);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/me/code/src/github.com/keybase/proofs/src/sig3.iced",
            funcname: "Base.check"
          });
          _this._check_clock_skew({
            now: now
          }, esc(__iced_deferrals.defer({
            lineno: 199
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(null);
        };
      })(this));
    };

    Base.prototype._check_clock_skew = function(_arg, cb) {
      var critical_clock_skew_secs, diff, epoch, err, now;
      now = _arg.now;
      critical_clock_skew_secs = constants.critical_clock_skew_secs;
      now || (now = unix_time());
      diff = Math.abs(now - this.ctime);
      if (Math.abs(diff) > critical_clock_skew_secs) {
        epoch = now > this.ctime ? "past" : "future";
        err = new errors.ClockSkewError("your computer's clock is wrong: signature is dated " + diff + " seconds in the " + epoch);
        err.diff = diff;
      }
      return cb(err);
    };

    Base.prototype._generate_outer = function(_arg) {
      var inner;
      inner = _arg.inner;
      return (new OuterLink({
        version: this._version(),
        seqno: this.seqno,
        prev: parse.unhex(this.prev),
        inner_hash: this._hash(inner),
        link_type: this._v_link_type_v3(),
        chain_type: this._v_chain_type_v3(),
        ignore_if_unsupported: this.ignore_if_unsupported
      })).encode();
    };

    Base.prototype.get_merkle_root_hex = function() {
      if (this.merkle_root == null) {
        return null;
      }
      return {
        hash_meta: this.merkle_root.hash_meta.toString('hex'),
        ctime: this.merkle_root.ctime,
        seqno: this.merkle_root.seqno
      };
    };

    Base.prototype.assert_is_v2_legacy = function() {
      return this._v_assert_is_v2_legacy();
    };

    Base.prototype.generate = function(opts, cb) {
      var armored, esc, inner, json, outer, raw, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/me/code/src/github.com/keybase/proofs/src/sig3.iced",
            funcname: "Base.generate"
          });
          _this._generate_inner(opts, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return inner = arguments[0];
              };
            })(),
            lineno: 235
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          outer = _this._generate_outer({
            inner: inner
          });
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/home/me/code/src/github.com/keybase/proofs/src/sig3.iced",
              funcname: "Base.generate"
            });
            _this._v_reverse_sign({
              inner: inner,
              outer: outer
            }, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  inner = arguments[0].inner;
                  return outer = arguments[0].outer;
                };
              })(),
              lineno: 237
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/me/code/src/github.com/keybase/proofs/src/sig3.iced",
                funcname: "Base.generate"
              });
              _this._sign({
                sig_eng: _this.sig_eng,
                outer: outer
              }, esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return sig = arguments[0];
                  };
                })(),
                lineno: 238
              })));
              __iced_deferrals._fulfill();
            })(function() {
              var _ref1;
              raw = {
                outer: outer,
                inner: inner,
                sig: sig
              };
              _ref1 = _encode_dict(raw), json = _ref1.json, armored = _ref1.armored;
              return cb(null, {
                raw: raw,
                armored: armored,
                json: json
              });
            });
          });
        };
      })(this));
    };

    return Base;

  })();

}).call(this);
