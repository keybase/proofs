// Generated by IcedCoffeeScript 108.0.11
(function() {
  var Base, Subkey, SubkeyBase, a_json_parse, constants, iced, json_cp, json_stringify_sorted, make_esc, pgp_utils, streq_secure, unix_time, __iced_k, __iced_k_noop, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  Base = require('./base').Base;

  constants = require('./constants').constants;

  make_esc = require('iced-error').make_esc;

  pgp_utils = require('pgp-utils');

  _ref = pgp_utils.util, json_stringify_sorted = _ref.json_stringify_sorted, unix_time = _ref.unix_time, streq_secure = _ref.streq_secure;

  a_json_parse = function(x, cb) {
    var e, err, ret;
    ret = err = null;
    try {
      ret = JSON.parse(x);
    } catch (_error) {
      e = _error;
      err = e;
    }
    return cb(err, ret);
  };

  json_cp = function(x) {
    return JSON.parse(JSON.stringify(x));
  };

  exports.SubkeyBase = SubkeyBase = (function(_super) {
    __extends(SubkeyBase, _super);

    SubkeyBase.prototype.get_new_key_section = function() {
      return null;
    };

    SubkeyBase.prototype.set_new_key_section = function(s) {};

    SubkeyBase.prototype.get_new_km = function() {
      return null;
    };

    SubkeyBase.prototype.get_key_field = function() {
      return null;
    };

    SubkeyBase.prototype.need_reverse_sig = function() {
      return false;
    };

    SubkeyBase.prototype._optional_sections = function() {
      return SubkeyBase.__super__._optional_sections.call(this).concat(["device"]);
    };

    SubkeyBase.prototype._v_pgp_details_dest = function(body) {
      return body[this.get_key_field()];
    };

    SubkeyBase.prototype._v_pgp_km = function() {
      return this.get_new_km();
    };

    SubkeyBase.prototype._v_generate = function(opts, cb) {
      var armored, eng, esc, msg, obj, type, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "_v_generate");
      (function(_this) {
        return (function(__iced_k) {
          if ((_this.get_new_key_section() == null) && (_this.get_new_km() != null)) {
            obj = {
              reverse_sig: null
            };
            if (_this.sibkid_slot() != null) {
              obj[_this.sibkid_slot()] = _this.get_new_km().get_ekid().toString('hex');
            }
            if (_this.parent_kid != null) {
              obj.parent_kid = _this.parent_kid;
            }
            _this.set_new_key_section(obj);
            (function(__iced_k) {
              if (_this.get_new_km().can_sign()) {
                eng = _this.get_new_km().make_sig_eng();
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/me/code/src/github.com/keybase/proofs/src/subkey.iced",
                    funcname: "SubkeyBase._v_generate"
                  });
                  _this.generate_json({
                    version: opts.version
                  }, esc(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return msg = arguments[0];
                      };
                    })(),
                    lineno: 40
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/home/me/code/src/github.com/keybase/proofs/src/subkey.iced",
                      funcname: "SubkeyBase._v_generate"
                    });
                    eng.box(msg, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          armored = arguments[0].armored;
                          return type = arguments[0].type;
                        };
                      })(),
                      lineno: 41
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    return __iced_k(obj.reverse_sig = armored);
                  });
                });
              } else {
                return __iced_k();
              }
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb(null);
        };
      })(this));
    };

    SubkeyBase.prototype._v_customize_json = function(ret) {
      ret.body[this.get_key_field()] = this.get_new_key_section();
      if (this.device != null) {
        return ret.body.device = this.device;
      }
    };

    SubkeyBase.prototype.sibkid_slot = function() {
      return "kid";
    };

    SubkeyBase.prototype._match_json = function(outer, inner) {
      var a, b, err;
      outer = json_cp(outer);
      this._clear_reverse_sig(outer);
      a = json_stringify_sorted(outer);
      b = json_stringify_sorted(inner);
      err = null;
      if (!streq_secure(a, b)) {
        err = new Error("Reverse sig json mismatch: " + a + " != " + b);
      }
      return err;
    };

    SubkeyBase.prototype._v_check = function(_arg, cb) {
      var esc, json, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      json = _arg.json;
      esc = make_esc(cb, "SubkeyBase::_v_check");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/me/code/src/github.com/keybase/proofs/src/subkey.iced",
            funcname: "SubkeyBase._v_check"
          });
          SubkeyBase.__super__._v_check.call(_this, {
            json: json
          }, esc(__iced_deferrals.defer({
            lineno: 63
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/home/me/code/src/github.com/keybase/proofs/src/subkey.iced",
              funcname: "SubkeyBase._v_check"
            });
            _this.reverse_sig_check({
              json: json,
              new_km: _this.get_new_km()
            }, esc(__iced_deferrals.defer({
              lineno: 64
            })));
            __iced_deferrals._fulfill();
          })(function() {
            return cb(null);
          });
        };
      })(this));
    };

    SubkeyBase.prototype._get_reverse_sig = function(json) {
      var _ref1, _ref2;
      return json != null ? (_ref1 = json.body) != null ? (_ref2 = _ref1[this.get_key_field()]) != null ? _ref2.reverse_sig : void 0 : void 0 : void 0;
    };

    SubkeyBase.prototype._get_new_sibkid = function(json) {
      var _ref1, _ref2;
      return json != null ? (_ref1 = json.body) != null ? (_ref2 = _ref1[this.get_key_field()]) != null ? _ref2[this.sibkid_slot()] : void 0 : void 0 : void 0;
    };

    SubkeyBase.prototype._clear_reverse_sig = function(outer) {
      return outer.body[this.get_key_field()].reverse_sig = null;
    };

    SubkeyBase.prototype.reverse_sig_check = function(_arg, cb) {
      var a, b, eng, err, esc, json, new_km, payload, raw, rsk, sig, subkm, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      json = _arg.json, new_km = _arg.new_km, subkm = _arg.subkm;
      new_km || (new_km = subkm);
      esc = make_esc(cb, "SubkeyBase::reverse_sig_check");
      err = null;
      (function(_this) {
        return (function(__iced_k) {
          if (((sig = _this._get_reverse_sig(json)) != null) && (new_km != null)) {
            eng = new_km.make_sig_eng();
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/me/code/src/github.com/keybase/proofs/src/subkey.iced",
                funcname: "SubkeyBase.reverse_sig_check"
              });
              eng.unbox(sig, esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return raw = arguments[0];
                  };
                })(),
                lineno: 84
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/me/code/src/github.com/keybase/proofs/src/subkey.iced",
                  funcname: "SubkeyBase.reverse_sig_check"
                });
                a_json_parse(raw, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return payload = arguments[0];
                    };
                  })(),
                  lineno: 85
                })));
                __iced_deferrals._fulfill();
              })(function() {
                rsk = new_km.get_ekid().toString('hex');
                return __iced_k((err = _this._match_json(json, payload)) != null ? void 0 : !streq_secure((a = _this._get_new_sibkid(json)), (b = rsk)) ? err = new Error("Sibkey KID mismatch: " + a + " != " + b) : _this.reverse_sig_kid = rsk);
              });
            });
          } else {
            return __iced_k(_this.need_reverse_sig(json) ? err = new Error("Need a reverse sig, but didn't find one") : void 0);
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb(err);
        };
      })(this));
    };

    function SubkeyBase(obj) {
      this.device = obj.device;
      SubkeyBase.__super__.constructor.call(this, obj);
    }

    return SubkeyBase;

  })(Base);

  exports.Subkey = Subkey = (function(_super) {
    __extends(Subkey, _super);

    Subkey.prototype.get_key_field = function() {
      return "subkey";
    };

    Subkey.prototype._type_v2 = function() {
      return constants.sig_types_v2.subkey;
    };

    Subkey.prototype.get_new_key_section = function() {
      return this.subkey;
    };

    Subkey.prototype.set_new_key_section = function(s) {
      return this.subkey = s;
    };

    Subkey.prototype.get_new_km = function() {
      return this.subkm;
    };

    Subkey.prototype._type = function() {
      return constants.sig_types.subkey;
    };

    Subkey.prototype._required_sections = function() {
      return Subkey.__super__._required_sections.call(this).concat(["subkey"]);
    };

    function Subkey(obj) {
      this.subkey = obj.subkey;
      this.subkm = obj.subkm;
      this.parent_kid = obj.parent_kid;
      Subkey.__super__.constructor.call(this, obj);
    }

    return Subkey;

  })(SubkeyBase);

}).call(this);
