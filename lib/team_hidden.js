// Generated by IcedCoffeeScript 108.0.11
(function() {
  var Base, EncKeyManager, KeyManager, RotateKey, TeamBase, constants, iced, make_esc, pack, parse, schema, unpack, __iced_k, __iced_k_noop, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  Base = require('./sig3').Base;

  constants = require('./constants').constants;

  parse = require('./parse3');

  _ref = require('kbpgp').kb, EncKeyManager = _ref.EncKeyManager, KeyManager = _ref.KeyManager;

  make_esc = require('iced-error').make_esc;

  schema = require('./schema3');

  _ref1 = require('purepack'), pack = _ref1.pack, unpack = _ref1.unpack;

  exports.TeamBase = TeamBase = (function(_super) {
    __extends(TeamBase, _super);

    function TeamBase(args) {
      this.team = args.team;
      TeamBase.__super__.constructor.call(this, args);
    }

    TeamBase.prototype._v_encode_inner = function(_arg) {
      var json, obj;
      json = _arg.json;
      obj = {
        i: Buffer.from(this.team.id, 'hex')
      };
      if (this.team.is_implicit) {
        obj.m = true;
      }
      if (this.team.is_public) {
        obj.p = true;
      }
      return json.t = obj;
    };

    TeamBase.prototype._v_extend_schema = function(schm) {
      return schm.set_key("t", schema.dict({
        i: schema.binary(16).name("team_id"),
        m: schema.bool().optional().name("is_implicit"),
        p: schema.bool().optional().name("is_public")
      }));
    };

    TeamBase.prototype._v_decode_inner = function(_arg, cb) {
      var json;
      json = _arg.json;
      this.team = {
        id: json.t.i,
        is_public: !!json.t.p,
        is_implicit: !!json.t.m
      };
      return cb(null);
    };

    TeamBase.prototype.to_v2_team_obj = function() {
      return {
        id: this.team.id.toString('hex'),
        is_implicit: this.team.is_implicit,
        is_public: this.team.is_public
      };
    };

    return TeamBase;

  })(Base);

  exports.RotateKey = RotateKey = (function(_super) {
    __extends(RotateKey, _super);

    function RotateKey(args) {
      this.per_team_keys = args.per_team_keys;
      RotateKey.__super__.constructor.call(this, args);
    }

    RotateKey.prototype._v_encode_inner = function(_arg) {
      var json, k, keys;
      json = _arg.json;
      RotateKey.__super__._v_encode_inner.call(this, {
        json: json
      });
      keys = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = this.per_team_keys;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          k = _ref2[_i];
          _results.push({
            a: constants.appkey_derivation_version.hmac,
            e: k.enc_km.key.ekid(),
            g: k.generation,
            r: null,
            s: k.sig_km.key.ekid(),
            t: k.ptk_type
          });
        }
        return _results;
      }).call(this);
      return json.b = {
        k: keys
      };
    };

    RotateKey.prototype._v_extend_schema = function(schm) {
      var elem;
      RotateKey.__super__._v_extend_schema.call(this, schm);
      elem = schema.dict({
        a: schema.value(constants.appkey_derivation_version.hmac).name("appkey_derivation_version"),
        e: schema.enc_kid().name("encryption_kid"),
        g: schema.seqno().name("generation"),
        r: schema.binary(64).name("reverse_sig"),
        s: schema.kid().name("signing_kid"),
        t: schema.ptk_type().name("ptk_type")
      }).name("key");
      return schm.set_key("b", schema.dict({
        k: schema.array(elem).name("keys")
      }).name("body"));
    };

    RotateKey.prototype._decode_key = function(_arg, cb) {
      var esc, key, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      key = _arg.key;
      esc = make_esc(cb);
      ret = {
        generation: key.g,
        appkey_derivation_version: key.a,
        reverse_sig: key.r,
        ptk_type: key.t
      };
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/me/code/src/github.com/keybase/proofs/src/team_hidden.iced",
            funcname: "RotateKey._decode_key"
          });
          EncKeyManager.import_public({
            raw: key.e
          }, esc(__iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                return __slot_1.enc_km = arguments[0];
              };
            })(ret),
            lineno: 88
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/home/me/code/src/github.com/keybase/proofs/src/team_hidden.iced",
              funcname: "RotateKey._decode_key"
            });
            KeyManager.import_public({
              raw: key.s
            }, esc(__iced_deferrals.defer({
              assign_fn: (function(__slot_1) {
                return function() {
                  return __slot_1.sig_km = arguments[0];
                };
              })(ret),
              lineno: 89
            })));
            __iced_deferrals._fulfill();
          })(function() {
            return cb(null, ret);
          });
        };
      })(this));
    };

    RotateKey.prototype._v_decode_inner = function(_arg, cb) {
      var esc, json, key, ptk, seen, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      json = _arg.json;
      esc = make_esc(cb);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/me/code/src/github.com/keybase/proofs/src/team_hidden.iced",
            funcname: "RotateKey._v_decode_inner"
          });
          RotateKey.__super__._v_decode_inner.call(_this, {
            json: json
          }, esc(__iced_deferrals.defer({
            lineno: 94
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          _this.per_team_keys = [];
          seen = {};
          (function(__iced_k) {
            var _i, _len, _ref2, _results, _while;
            _ref2 = json.b.k;
            _len = _ref2.length;
            _i = 0;
            _while = function(__iced_k) {
              var _break, _continue, _next;
              _break = __iced_k;
              _continue = function() {
                return iced.trampoline(function() {
                  ++_i;
                  return _while(__iced_k);
                });
              };
              _next = _continue;
              if (!(_i < _len)) {
                return _break();
              } else {
                key = _ref2[_i];
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/me/code/src/github.com/keybase/proofs/src/team_hidden.iced",
                    funcname: "RotateKey._v_decode_inner"
                  });
                  _this._decode_key({
                    key: key
                  }, esc(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return ptk = arguments[0];
                      };
                    })(),
                    lineno: 98
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  if (seen[ptk.ptk_type]) {
                    return cb(new Error("Repeated PTK type " + ptk.ptk_type + " not allowed"));
                  }
                  seen[ptk.ptk_type] = true;
                  return _next(_this.per_team_keys.push(ptk));
                });
              }
            };
            _while(__iced_k);
          })(function() {
            return cb(null);
          });
        };
      })(this));
    };

    RotateKey.prototype._v_reverse_sign = function(_arg, cb) {
      var esc, i, inner, k, outer, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      inner = _arg.inner, outer = _arg.outer;
      esc = make_esc(cb);
      (function(_this) {
        return (function(__iced_k) {
          var _i, _len, _ref2, _results, _while;
          _ref2 = _this.per_team_keys;
          _len = _ref2.length;
          i = 0;
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = __iced_k;
            _continue = function() {
              return iced.trampoline(function() {
                ++i;
                return _while(__iced_k);
              });
            };
            _next = _continue;
            if (!(i < _len)) {
              return _break();
            } else {
              k = _ref2[i];
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/me/code/src/github.com/keybase/proofs/src/team_hidden.iced",
                  funcname: "RotateKey._v_reverse_sign"
                });
                _this._sign({
                  sig_eng: k.sig_km.make_sig_eng(),
                  outer: outer
                }, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return sig = arguments[0];
                    };
                  })(),
                  lineno: 108
                })));
                __iced_deferrals._fulfill();
              })(function() {
                inner.b.k[i].r = sig;
                return _next(outer = _this._generate_outer({
                  inner: inner
                }));
              });
            }
          };
          _while(__iced_k);
        });
      })(this)((function(_this) {
        return function() {
          return cb(null, {
            inner: inner,
            outer: outer
          });
        };
      })(this));
    };

    RotateKey.prototype._v_verify_reverse_sig = function(_arg, cb) {
      var esc, i, inner, inner_hash, k, outer, outer_obj, payload, reverse_sigs, s, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      inner = _arg.inner, outer_obj = _arg.outer_obj;
      esc = make_esc(cb);
      reverse_sigs = [];
      reverse_sigs = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = inner.b.k;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          k = _ref2[_i];
          _results.push(k.r);
        }
        return _results;
      })();
      inner_hash = outer_obj.inner_hash;
      (function(_this) {
        return (function(__iced_k) {
          var _i, _len, _ref2, _results, _while;
          _ref2 = inner.b.k;
          _len = _ref2.length;
          i = _len - 1;
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = __iced_k;
            _continue = function() {
              return iced.trampoline(function() {
                i = i + -1;
                return _while(__iced_k);
              });
            };
            _next = _continue;
            if (!(i >= 0)) {
              return _break();
            } else {
              k = _ref2[i];
              sig = k.r;
              k.r = null;
              outer_obj.inner_hash = _this._hash(inner);
              outer = outer_obj.encode();
              payload = pack(outer);
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/me/code/src/github.com/keybase/proofs/src/team_hidden.iced",
                  funcname: "RotateKey._v_verify_reverse_sig"
                });
                _this.per_team_keys[i].sig_km.verify_raw({
                  prefix: _this._prefix(),
                  payload: payload,
                  sig: sig
                }, esc(__iced_deferrals.defer({
                  lineno: 124
                })));
                __iced_deferrals._fulfill();
              })(_next);
            }
          };
          _while(__iced_k);
        });
      })(this)((function(_this) {
        return function() {
          var _i, _len;
          for (i = _i = 0, _len = reverse_sigs.length; _i < _len; i = ++_i) {
            s = reverse_sigs[i];
            inner.b.k[i].r = s;
          }
          return cb(null);
        };
      })(this));
    };

    RotateKey.prototype._v_link_type_v3 = function() {
      return constants.sig_types_v3.team.rotate_key;
    };

    RotateKey.prototype._v_chain_type_v3 = function() {
      return constants.seq_types.TEAM_HIDDEN;
    };

    RotateKey.prototype._v_assert_is_v2_legacy = function() {
      if (typeof err !== "undefined" && err !== null) {
        return err;
      }
      if (this.per_team_keys.length !== 1) {
        return new Error("need exactly one PTK");
      }
      if (this.per_team_keys[0].ptk_type !== constants.ptk_types.reader) {
        return new Error("need a reader PTK (no current support for bot or admin keys)");
      }
      return null;
    };

    RotateKey.prototype.to_v2_team_obj = function() {
      var k, ret;
      ret = RotateKey.__super__.to_v2_team_obj.call(this);
      k = this.per_team_keys[0];
      ret.per_team_key = {
        encryption_kid: k.enc_km.key.ekid().toString('hex'),
        signing_kid: k.sig_km.key.ekid().toString('hex'),
        generation: k.generation,
        reverse_sig: k.reverse_sig.toString('base64')
      };
      return ret;
    };

    return RotateKey;

  })(TeamBase);

}).call(this);
