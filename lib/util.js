// Generated by IcedCoffeeScript 108.0.11
(function() {
  var Lock, bufeq_secure, constants, crypto, json_secure_compare, json_stringify_sorted, pack, v2_sig_type_from_sig_type, _ref;

  constants = require('./constants').constants;

  _ref = require('pgp-utils').util, json_stringify_sorted = _ref.json_stringify_sorted, bufeq_secure = _ref.bufeq_secure;

  crypto = require('crypto');

  pack = require('purepack').pack;

  exports.json_secure_compare = json_secure_compare = function(a, b) {
    var err, o1, o2, x, _ref1;
    _ref1 = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = [a, b];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        x = _ref1[_i];
        _results.push(json_stringify_sorted(x));
      }
      return _results;
    })(), o1 = _ref1[0], o2 = _ref1[1];
    err = bufeq_secure(Buffer.from(o1, 'utf8'), Buffer.from(o2, 'utf8')) ? null : new Error("Json objects differed: " + o1 + " != " + o2);
    return err;
  };

  exports.v2_sig_type_from_sig_type = v2_sig_type_from_sig_type = function(type) {
    var k, keys, v, _i, _len;
    keys = type.split(".");
    v = constants.sig_types_v2;
    for (_i = 0, _len = keys.length; _i < _len; _i++) {
      k = keys[_i];
      v = v[k];
    }
    return v;
  };

  exports.bufferify = function(b) {
    if (Buffer.isBuffer(b)) {
      return b;
    } else {
      return Buffer.from(b, 'utf8');
    }
  };

  exports.Lock = Lock = (function() {
    function Lock() {
      this._open = true;
      this._waiters = [];
    }

    Lock.prototype.acquire = function(cb) {
      if (this._open) {
        this._open = false;
        return cb();
      } else {
        return this._waiters.push(cb);
      }
    };

    Lock.prototype.release = function() {
      var w;
      if (this._waiters.length) {
        w = this._waiters.shift();
        return w();
      } else {
        return this._open = true;
      }
    };

    Lock.prototype.open = function() {
      return this._open;
    };

    return Lock;

  })();

  exports.space_normalize = function(s) {
    return s.split(/[\r\n\t ]+/).join(' ');
  };

  exports.sha256 = function(b) {
    return crypto.createHash('SHA256').update(b).digest('buffer');
  };

  exports.pack = function(o) {
    return pack(o, {
      sort_keys: true
    });
  };

}).call(this);
